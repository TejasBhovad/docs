"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[528],{7126:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>u,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var t=e(7462),s=(e(7294),e(3905)),o=e(814);const r={sidebar_position:2,description:"function calls itself"},a="Recursion",c={unversionedId:"basics/recursion",id:"basics/recursion",title:"Recursion",description:"function calls itself",source:"@site/docs/basics/recursion.mdx",sourceDirName:"basics",slug:"/basics/recursion",permalink:"/docs/basics/recursion",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"function calls itself"},sidebar:"tutorialSidebar",previous:{title:"Arrays",permalink:"/docs/basics/arrays"},next:{title:"Stacks and Queues",permalink:"/docs/category/stacks-and-queues"}},u={},d=[{value:"Definintion",id:"definintion",level:2}],l={toc:d};function p(n){let{components:i,...e}=n;return(0,s.kt)("wrapper",(0,t.Z)({},l,e,{components:i,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"recursion"},"Recursion"),(0,s.kt)("h2",{id:"definintion"},"Definintion"),(0,s.kt)("p",null,"when a function calls itself from its body, the function is said to be a recursive function."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Recursive functions should always have a termination condition else the function calls itself infinitely.")),(0,s.kt)(o.Z,{language:"c",mdxType:"CodeBlock"},"#include <stdio.h>\nvoid recurse()\n{\n    // Body that will contain the termination condition\n    recurse();\n}\nint main()\n{\n    recurse();\n    return 0;\n}"),(0,s.kt)("p",null,"Find Recursion programs here:",(0,s.kt)("br",null),"\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/TejasBhovad/c-programs/blob/master/recursion/recursion.md"},"https://github.com/TejasBhovad/c-programs/recursion")))}p.isMDXComponent=!0}}]);