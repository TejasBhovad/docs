"use strict";(self.webpackChunkdocsv_2=self.webpackChunkdocsv_2||[]).push([[5995],{9458:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>u,metadata:()=>d,toc:()=>c});var t=r(5893),i=r(1151),s=r(9286);const a='#include <stdio.h>\n\n// GLOBAL VARIABLES\nint front = -1, rear = -1;\nint N;\n\n// FUNCTION PROTOTYPE\nvoid enqueue(int *ptr, int x);\nvoid dequeue(int *ptr);\nvoid display(int *ptr);\n\nint main()\n{\n    printf("Enter N : \\n");\n    scanf("%d", &N);\n    int ar[N], choice;\n    do\n    {\n        printf("\\nEnter Choice:");\n        printf("\\n1. Queue");\n        printf("\\n2. Dequeue");\n        printf("\\n3. Display");\n        printf("\\n4. Exit\\n");\n        scanf("%d", &choice);\n        switch (choice)\n        {\n        case 1:\n        {\n            int x;\n            printf("\\nEnter Element to Queue: ");\n            scanf("%d", &x);\n            enqueue(ar, x);\n            break;\n        }\n        case 2:\n        {\n            dequeue(ar);\n            break;\n        }\n        case 3:\n        {\n            display(ar);\n            break;\n        }\n        case 4:\n        {\n            printf(" ");\n            break;\n        }\n\n        default:\n        {\n            printf("\\nInvalid choice");\n            break;\n        }\n        }\n    } while (choice != 4);\n    printf("\\n");\n    return 0;\n}\n\n// ENQUEUE FUNCTION\nvoid enqueue(int *ptr, int x)\n{\n    if (rear == N - 1)\n    {\n        printf("\\nOverflow Error");\n    }\n    else\n    {\n        if (rear == -1 && front == -1)\n        {\n            front = 0;\n            rear = 0;\n            *(ptr + rear) = x;\n        }\n        else\n        {\n            rear++;\n            *(ptr + rear) = x;\n        }\n    }\n}\n\n// DEQUEUE FUNCTION\nvoid dequeue(int *ptr)\n{\n    if (front > rear || front == -1 && rear == -1)\n    {\n        printf("\\nUnderflow Error");\n    }\n    else\n    {\n        printf("\\n%d is Dequeued", *(ptr + front));\n        front++;\n    }\n}\n\n// DISPLAY FUNCTION\nvoid display(int *ptr)\n{\n    printf("\\nElements in Queue: \\n");\n    for (int i = front; i <= rear; i++)\n    {\n        printf(" %d", *(ptr + i));\n    }\n}',u={sidebar_position:1,description:"Linear Queues Operations Program"},o="Linear Queues",d={id:"Data Structures/queues/linear-queues",title:"Linear Queues",description:"Linear Queues Operations Program",source:"@site/docs/two/Data Structures/queues/linear-queues.mdx",sourceDirName:"Data Structures/queues",slug:"/Data Structures/queues/linear-queues",permalink:"/docs/two/Data Structures/queues/linear-queues",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Linear Queues Operations Program"},sidebar:"tutorialSidebar",previous:{title:"Queues",permalink:"/docs/two/category/queues"},next:{title:"Circular Queues",permalink:"/docs/two/Data Structures/queues/circular-queues"}},l={},c=[{value:"Operations",id:"operations",level:3},{value:"Errors",id:"errors",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Code",id:"code",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"linear-queues",children:"Linear Queues"}),"\n",(0,t.jsxs)(n.p,{children:["Elements in queues are added from one end and deleted from other.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"\nThe end from which elements are added is called ",(0,t.jsx)(n.strong,{children:"rear end"}),", and the end from where elements are deleted is called ",(0,t.jsx)(n.strong,{children:"front end"}),".\nTherefore Queues are ",(0,t.jsx)(n.strong,{children:"First in First Out"})]}),"\n",(0,t.jsx)(n.h3,{id:"operations",children:"Operations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enqueue"}),": Adding elements to the queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dequeue"}),": Removing elements from the queue"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"errors",children:"Errors"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Overflow"}),": When the queue is full but user tries to enqueue an element."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// condition:\nrear == N - 1\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Underflow"}),": When the queue is empty but user tried to denqueue an element."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,t.jsx)(n.p,{children:"When elements are popped the size of queue decreases."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// condition:\n(front > rear) OR (front == -1 && rear == -1)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"code",children:"Code"}),"\n",(0,t.jsx)(s.Z,{language:"c",children:a})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);