"use strict";(self.webpackChunkdocsv_2=self.webpackChunkdocsv_2||[]).push([[4566],{1678:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>u});var r=t(5893),d=t(1151),i=t(9286);const a='// Generated by ChatGPT\n#include <stdio.h>\n#include <stdlib.h>\n\n// Node structure\ntypedef struct NODE\n{\n    int data;\n    struct NODE *next;\n};\n\n// Global variables\nNODE *head = NULL;\n\n// Function to add a node at the start of the list\nvoid addAtStart(int data)\n{\n    NODE *newNode = (NODE *)malloc(sizeof(NODE));\n    newNode->data = data;\n    newNode->next = head;\n    head = newNode;\n}\n\n// Function to add a node at the end of the list\nvoid addAtEnd(int data)\n{\n    NODE *newNode = (NODE *)malloc(sizeof(NODE));\n    newNode->data = data;\n    newNode->next = NULL;\n\n    if (head == NULL)\n    {\n        head = newNode;\n        return;\n    }\n\n    NODE *curr = head;\n    while (curr->next != NULL)\n    {\n        curr = curr->next;\n    }\n    curr->next = newNode;\n}\n\n// Function to add a node before a given node\nvoid addBefore(int key, int data)\n{\n    NODE *newNode = (NODE *)malloc(sizeof(NODE));\n    newNode->data = data;\n    newNode->next = NULL;\n\n    if (head == NULL)\n    {\n        printf("List is empty\\n");\n        return;\n    }\n\n    if (head->data == key)\n    {\n        newNode->next = head;\n        head = newNode;\n        return;\n    }\n\n    NODE *curr = head;\n    while (curr->next != NULL && curr->next->data != key)\n    {\n        curr = curr->next;\n    }\n\n    if (curr->next == NULL)\n    {\n        printf("Key not found\\n");\n        return;\n    }\n\n    newNode->next = curr->next;\n    curr->next = newNode;\n}\n\n// Function to add a node after a given node\nvoid addAfter(int key, int data)\n{\n    NODE *newNode = (NODE *)malloc(sizeof(NODE));\n    newNode->data = data;\n    newNode->next = NULL;\n\n    if (head == NULL)\n    {\n        printf("List is empty\\n");\n        return;\n    }\n\n    NODE *curr = head;\n    while (curr != NULL && curr->data != key)\n    {\n        curr = curr->next;\n    }\n\n    if (curr == NULL)\n    {\n        printf("Key not found\\n");\n        return;\n    }\n\n    newNode->next = curr->next;\n    curr->next = newNode;\n}\n\n// Function to delete the first node of the list\nvoid deleteStart()\n{\n    if (head == NULL)\n    {\n        printf("List is empty\\n");\n        return;\n    }\n\n    NODE *temp = head;\n    head = head->next;\n    free(temp);\n}\n\n// Function to delete the last node of the list\nvoid deleteEnd()\n{\n    if (head == NULL)\n    {\n        printf("List is empty\\n");\n        return;\n    }\n\n    if (head->next == NULL)\n    {\n        free(head);\n        head = NULL;\n        return;\n    }\n\n    NODE *curr = head;\n    while (curr->next->next != NULL)\n    {\n        curr = curr->next;\n    }\n    free(curr->next);\n    curr->next = NULL;\n}\n\n// Function to delete a node with a given key\nvoid deleteKey(int key)\n{\n    if (head == NULL)\n    {\n        printf("List is empty\\n");\n        return;\n    }\n\n    if (head->data == key)\n    {\n        NODE *temp = head;\n        head = head->next;\n        free(temp);\n        return;\n    }\n\n    NODE *curr = head;\n    while (curr->next != NULL && curr->next->data != key)\n    {\n        curr = curr->next;\n    }\n\n    if (curr->next == NULL)\n    {\n        printf("Key not found\\n");\n        return;\n    }\n\n    NODE *temp = curr->next;\n    curr->next = curr->next->next;\n    free(temp);\n}\n\n// Function to print the list\nvoid printList()\n{\n    NODE *curr = head;\n    while (curr != NULL)\n    {\n        printf("%d ", curr->data);\n        curr = curr->next;\n    }\n    printf("\\n");\n}\n\n// Main function\nint main()\n{\n    int choice, data, key;\n    while (1)\n    {\n        printf("\\n1. Add at start\\n2. Add at end\\n3. Add before\\n4. Add after\\n");\n        printf("5. Delete start\\n6. Delete end\\n7. Delete key\\n8. Print list\\n9. Exit\\n");\n        printf("Enter your choice: ");\n        scanf("%d", &choice);\n\n        switch (choice)\n        {\n        case 1:\n            printf("Enter data to add at start: ");\n            scanf("%d", &data);\n            addAtStart(data);\n            break;\n        case 2:\n            printf("Enter data to add at end: ");\n            scanf("%d", &data);\n            addAtEnd(data);\n            break;\n        case 3:\n            printf("Enter key before which to add data: ");\n            scanf("%d", &key);\n            printf("Enter data to add before %d: ", key);\n            scanf("%d", &data);\n            addBefore(key, data);\n            break;\n        case 4:\n            printf("Enter key after which to add data: ");\n            scanf("%d", &key);\n            printf("Enter data to add after %d: ", key);\n            scanf("%d", &data);\n            addAfter(key, data);\n            break;\n        case 5:\n            deleteStart();\n            break;\n        case 6:\n            deleteEnd();\n            break;\n        case 7:\n            printf("Enter key to delete: ");\n            scanf("%d", &key);\n            deleteKey(key);\n            break;\n        case 8:\n            printf("List: ");\n            printList();\n            break;\n        case 9:\n            exit(0);\n        default:\n            printf("Invalid choice\\n");\n        }\n    }\n\n    return 0;\n}',c={sidebar_position:2,description:"Singly Circular Linked List in C"},s="Singly Circular Linked List",o={id:"Data Structures/linkedlist/singly-circular",title:"Singly Circular Linked List",description:"Singly Circular Linked List in C",source:"@site/docs/two/Data Structures/linkedlist/singly-circular.mdx",sourceDirName:"Data Structures/linkedlist",slug:"/Data Structures/linkedlist/singly-circular",permalink:"/docs/two/Data Structures/linkedlist/singly-circular",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Singly Circular Linked List in C"},sidebar:"tutorialSidebar",previous:{title:"Singly Linked List",permalink:"/docs/two/Data Structures/linkedlist/singly"},next:{title:"Binary Search Tree",permalink:"/docs/two/category/binary-search-tree"}},l={},u=[{value:"CASES IN INSERTION",id:"cases-in-insertion",level:2},{value:"CASES IN DELETION",id:"cases-in-deletion",level:2},{value:"CODE",id:"code",level:2}];function f(n){const e={h1:"h1",h2:"h2",li:"li",ol:"ol",...(0,d.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"singly-circular-linked-list",children:"Singly Circular Linked List"}),"\n",(0,r.jsx)(e.h2,{id:"cases-in-insertion",children:"CASES IN INSERTION"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"At Start of linkedlist"}),"\n",(0,r.jsx)(e.li,{children:"At End of linkedlist"}),"\n",(0,r.jsx)(e.li,{children:"After a defined(key) element"}),"\n",(0,r.jsx)(e.li,{children:"Before a defined(key) element"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"cases-in-deletion",children:"CASES IN DELETION"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Delete Elements from Start"}),"\n",(0,r.jsx)(e.li,{children:"Delete Elements from End"}),"\n",(0,r.jsx)(e.li,{children:"Delete Inputted Elements"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"code",children:"CODE"}),"\n",(0,r.jsx)(i.Z,{language:"c",children:a})]})}function h(n={}){const{wrapper:e}={...(0,d.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(f,{...n})}):f(n)}}}]);