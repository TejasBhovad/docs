"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[570],{1863:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>p,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>d,toc:()=>f});var t=i(7462),r=(i(7294),i(3905)),o=i(814),u=i(9512);const s={sidebar_position:9,description:"Graphs in C"},a="Graphs Traversal",d={unversionedId:"journal/DFS_BFS",id:"journal/DFS_BFS",title:"Graphs Traversal",description:"Graphs in C",source:"@site/docs/journal/DFS_BFS.mdx",sourceDirName:"journal",slug:"/journal/DFS_BFS",permalink:"/docs/journal/DFS_BFS",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,description:"Graphs in C"},sidebar:"tutorialSidebar",previous:{title:"Hash Tables",permalink:"/docs/journal/hash"}},p={},f=[],l={toc:f};function c(n){let{components:e,...i}=n;return(0,r.kt)("wrapper",(0,t.Z)({},l,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"graphs-traversal"},"Graphs Traversal"),(0,r.kt)(o.Z,{language:"c",mdxType:"CodeBlock"},u.Z))}c.isMDXComponent=!0},9512:(n,e,i)=>{i.d(e,{Z:()=>t});const t='#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODES 100\n\ntypedef struct Queue\n{\n    int arr[MAX_NODES];\n    int front, rear;\n} Queue;\n\nvoid init(Queue *q)\n{\n    q->front = q->rear = -1;\n}\n\nvoid enqueue(Queue *q, int node)\n{\n    if (q->rear == MAX_NODES - 1)\n    {\n        printf("Queue is full\\n");\n        return;\n    }\n    q->arr[++q->rear] = node;\n    if (q->front == -1)\n    {\n        q->front = 0;\n    }\n}\n\nint dequeue(Queue *q)\n{\n    if (q->front == -1 || q->front > q->rear)\n    {\n        printf("Queue is empty\\n");\n        return -1;\n    }\n    int node = q->arr[q->front++];\n    return node;\n}\n\nvoid bfs(int graph[MAX_NODES][MAX_NODES], int n)\n{\n    bool visited[MAX_NODES] = {false};\n    Queue queue;\n    init(&queue);\n    enqueue(&queue, 0);\n    visited[0] = true;\n    while (queue.front <= queue.rear)\n    {\n        int node = dequeue(&queue);\n        printf("%d ", node);\n        for (int i = 0; i < n; i++)\n        {\n            if (graph[node][i] == 1 && !visited[i])\n            {\n                visited[i] = true;\n                enqueue(&queue, i);\n            }\n        }\n    }\n    printf("\\n");\n}\n\nvoid dfs(int graph[MAX_NODES][MAX_NODES], int n)\n{\n    bool visited[MAX_NODES] = {false};\n    int stack[MAX_NODES];\n    int top = -1;\n    stack[++top] = 0;\n    visited[0] = true;\n    while (top != -1)\n    {\n        int node = stack[top--];\n        printf("%d ", node);\n        for (int i = 0; i < n; i++)\n        {\n            if (graph[node][i] == 1 && !visited[i])\n            {\n                visited[i] = true;\n                stack[++top] = i;\n            }\n        }\n    }\n    printf("\\n");\n}\n\nint main()\n{\n    int graph[MAX_NODES][MAX_NODES] = {{0, 1, 1, 0, 0, 0, 0, 0},\n                                       {1, 0, 0, 1, 1, 1, 0, 0},\n                                       {1, 0, 0, 0, 0, 1, 1, 1},\n                                       {0, 1, 0, 0, 0, 0, 0, 0},\n                                       {0, 1, 0, 0, 0, 0, 0, 0},\n                                       {0, 1, 1, 0, 0, 0, 0, 0},\n                                       {0, 0, 1, 0, 0, 0, 0, 0},\n                                       {0, 0, 1, 0, 0, 0, 0, 0}};\n    int n = 8;\n    printf("BFS: ");\n    bfs(graph, n);\n    printf("DFS: ");\n    dfs(graph, n);\n    return 0;\n}\n'}}]);