"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3928],{735:(n,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>d,metadata:()=>s,toc:()=>c});var e=t(7462),r=(t(7294),t(3905)),o=t(814);const d={sidebar_position:11,description:"Bellman Ford in C"},a="Bellman Ford",s={unversionedId:"algorithms/bellmanFord",id:"algorithms/bellmanFord",title:"Bellman Ford",description:"Bellman Ford in C",source:"@site/docs/algorithms/bellmanFord.mdx",sourceDirName:"algorithms",slug:"/algorithms/bellmanFord",permalink:"/docs/algorithms/bellmanFord",draft:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11,description:"Bellman Ford in C"},sidebar:"tutorialSidebar",previous:{title:"Huffman Coding",permalink:"/docs/algorithms/huffman"},next:{title:"Longest Common Subsequence",permalink:"/docs/algorithms/lcs"}},l={},c=[{value:"CODE",id:"code",level:2}],u={toc:c};function m(n){let{components:i,...t}=n;return(0,r.kt)("wrapper",(0,e.Z)({},u,t,{components:i,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"bellman-ford"},"Bellman Ford"),(0,r.kt)("h2",{id:"code"},"CODE"),(0,r.kt)(o.Z,{language:"c",mdxType:"CodeBlock"},'#include <stdio.h>\n\n#define INFINITY 9999\n#define MAX 10\n\nvoid bellmanFord(int G[MAX][MAX], int n, int startNode);\n\nint main() {\n    int G[MAX][MAX], i, j, n, u;\n    printf("Enter the no. of vertices: ");\n    scanf("%d", &n);\n    printf("\\nEnter the adjacency matrix:\\n");\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            scanf("%d", &G[i][j]);\n    printf("\\nEnter the starting node: ");\n    scanf("%d", &u);\n    bellmanFord(G, n, u);\n    return 0;\n}\n\nvoid bellmanFord(int G[MAX][MAX], int n, int startNode) {\n    int distance[MAX], pred[MAX];\n    \n    // INIT\n    for (int i = 0; i < n; i++) {\n        distance[i] = INFINITY;\n        pred[i] = -1;\n    }\n    distance[startNode] = 0;\n\n    // RELAXATION\n    for (int i = 0; i < n - 1; i++) {\n        for (int u = 0; u < n; u++) {\n            for (int v = 0; v < n; v++) {\n                if (G[u][v] != 0 && distance[u] + G[u][v] < distance[v]) {\n                    distance[v] = distance[u] + G[u][v];\n                    pred[v] = u;\n                }\n            }\n        }\n    }\n\n    // CHECK FOR NEGATIVE WEIGHT CYCLES\n    for (int u = 0; u < n; u++) {\n        for (int v = 0; v < n; v++) {\n            if (G[u][v] != 0 && distance[u] + G[u][v] < distance[v]) {\n                printf("Graph contains negative weight cycle.");\n                return;\n            }\n        }\n    }\n\n    // DISPLAY\n    for (int i = 0; i < n; i++) {\n        if (i != startNode) {\n            printf("\\nDistance of node %d = %d", i, distance[i]);\n            printf("\\nPath = %d", i);\n            int j = i;\n            while (j != startNode) {\n                j = pred[j];\n                printf(" <- %d", j);\n            }\n        }\n    }\n}\n'))}m.isMDXComponent=!0}}]);