"use strict";(self.webpackChunkdocsv_2=self.webpackChunkdocsv_2||[]).push([[551],{8167:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var t=e(5893),r=e(1151),o=e(9286);const d='#include <stdio.h>\n\n#define INFINITY 9999\n#define MAX 10\n\nvoid bellmanFord(int G[MAX][MAX], int n, int startNode);\n\nint main() {\n    int G[MAX][MAX], i, j, n, u;\n    printf("Enter the no. of vertices: ");\n    scanf("%d", &n);\n    printf("\\nEnter the adjacency matrix:\\n");\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            scanf("%d", &G[i][j]);\n    printf("\\nEnter the starting node: ");\n    scanf("%d", &u);\n    bellmanFord(G, n, u);\n    return 0;\n}\n\nvoid bellmanFord(int G[MAX][MAX], int n, int startNode) {\n    int distance[MAX], pred[MAX];\n    \n    // INIT\n    for (int i = 0; i < n; i++) {\n        distance[i] = INFINITY;\n        pred[i] = -1;\n    }\n    distance[startNode] = 0;\n\n    // RELAXATION\n    for (int i = 0; i < n - 1; i++) {\n        for (int u = 0; u < n; u++) {\n            for (int v = 0; v < n; v++) {\n                if (G[u][v] != 0 && distance[u] + G[u][v] < distance[v]) {\n                    distance[v] = distance[u] + G[u][v];\n                    pred[v] = u;\n                }\n            }\n        }\n    }\n\n    // CHECK FOR NEGATIVE WEIGHT CYCLES\n    for (int u = 0; u < n; u++) {\n        for (int v = 0; v < n; v++) {\n            if (G[u][v] != 0 && distance[u] + G[u][v] < distance[v]) {\n                printf("Graph contains negative weight cycle.");\n                return;\n            }\n        }\n    }\n\n    // DISPLAY\n    for (int i = 0; i < n; i++) {\n        if (i != startNode) {\n            printf("\\nDistance of node %d = %d", i, distance[i]);\n            printf("\\nPath = %d", i);\n            int j = i;\n            while (j != startNode) {\n                j = pred[j];\n                printf(" <- %d", j);\n            }\n        }\n    }\n}\n',a={sidebar_position:11,description:"Bellman Ford in C"},s="Bellman Ford",l={id:"algorithms/bellmanFord",title:"Bellman Ford",description:"Bellman Ford in C",source:"@site/docs/three/algorithms/bellmanFord.mdx",sourceDirName:"algorithms",slug:"/algorithms/bellmanFord",permalink:"/docs/three/algorithms/bellmanFord",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11,description:"Bellman Ford in C"},sidebar:"tutorialSidebar",previous:{title:"Huffman Coding",permalink:"/docs/three/algorithms/huffman"},next:{title:"Longest Common Subsequence",permalink:"/docs/three/algorithms/lcs"}},c={},u=[{value:"CODE",id:"code",level:2}];function f(n){const i={h1:"h1",h2:"h2",...(0,r.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"bellman-ford",children:"Bellman Ford"}),"\n",(0,t.jsx)(i.h2,{id:"code",children:"CODE"}),"\n",(0,t.jsx)(o.Z,{language:"c",children:d})]})}function m(n={}){const{wrapper:i}={...(0,r.a)(),...n.components};return i?(0,t.jsx)(i,{...n,children:(0,t.jsx)(f,{...n})}):f(n)}}}]);