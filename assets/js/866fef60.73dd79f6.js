"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8794],{8434:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>k,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var o=e(7462),i=(e(7294),e(3905)),r=e(814);const s={sidebar_position:2,description:"Stacks in C"},a="Stack",p={unversionedId:"c/stacks/stacks",id:"c/stacks/stacks",title:"Stack",description:"Stacks in C",source:"@site/docs/c/stacks/stacks.mdx",sourceDirName:"c/stacks",slug:"/c/stacks/",permalink:"/docs/c/stacks/",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Stacks in C"},sidebar:"tutorialSidebar",previous:{title:"Tower of Hanoi",permalink:"/docs/c/stacks/hanoiTower"},next:{title:"Infix to Postfix Conversion",permalink:"/docs/c/stacks/postfix-convert"}},l={},c=[{value:"Operations",id:"operations",level:2},{value:"Errors",id:"errors",level:2},{value:"Code",id:"code",level:2}],d={toc:c};function k(n){let{components:t,...e}=n;return(0,i.kt)("wrapper",(0,o.Z)({},d,e,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"stack"},"Stack"),(0,i.kt)("p",null,"A stack has only one entry/exit point."),(0,i.kt)("p",null,"LIFO: Last in First Out. It implies that the element that is inserted last, comes out first."),(0,i.kt)("p",null,"Stack is used for managing order of processes"),(0,i.kt)("h2",{id:"operations"},"Operations"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Push"),": add an element to the stack ",(0,i.kt)("br",null),"\n",(0,i.kt)("strong",{parentName:"p"},"Pop"),": remove an element from the stack",(0,i.kt)("br",null),"\n",(0,i.kt)("strong",{parentName:"p"},"Peek"),": display the topmost element of the stack"),(0,i.kt)("h2",{id:"errors"},"Errors"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Stack overflow"),": When user tries to add an element to a already full stack."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Stack underflow"),": When user tries to remove an element from an empty stack.")),(0,i.kt)("h2",{id:"code"},"Code"),(0,i.kt)(r.Z,{language:"c",mdxType:"CodeBlock"},'#include <stdio.h>\n\n// FUNCTION PROTOTYPES\nvoid push(int *ptr);\nvoid pop(int *ptr);\nvoid display(int *ptr);\nint peek(int *ptr);\n\n// GLOBAL VARIABLES\nint top = -1;\nint N;\n\nint main()\n{\n    printf("Enter N : \\n");\n    scanf("%d", &N);\n    int ar[N];\n\n    // ACCEPTING N ELEMENTS OF STACK\n    for (int i = 0; i < N; i++)\n    {\n        push(ar);\n    }\n\n    display(ar);\n    pop(ar);\n    pop(ar);\n    display(ar);\n    push(ar);\n    display(ar);\n\n    int topmost = peek(ar);\n    printf("\\nTopmost element: %d", topmost);\n    printf("\\n");\n\n    return 0;\n}\n\n// INPUT STACK ELEMENTS\nvoid push(int *ptr)\n{\n    // STACK OVERFLOW\n    if (top == N - 1)\n    {\n        printf("\\nStack Overflow");\n    }\n    else\n    {\n        top++;\n        printf("\\nEnter Element Stack[%d]: ", top + 1);\n        scanf("%d", &*(ptr + top));\n        // *(ptr + top) = x;\n    }\n}\n\n// REMOVE STACK ELEMENT\nvoid pop(int *ptr)\n{\n    // STACK UNDERFLOW\n    if (top == -1)\n    {\n        printf("\\nNo Element to POP");\n    }\n    else\n    {\n        printf("\\nRemoved Element: %d", *(ptr + top));\n        top--;\n    }\n}\n\n// DISPLAY THE STACK\nvoid display(int *ptr)\n{\n    printf("\\nElements in Stack:\\n");\n    for (int i = 0; i <= top; i++)\n    {\n        printf(" %d", *(ptr + i));\n    }\n}\n\n// PEEK: DISPLAY TOPMOST ELEMENT\nint peek(int *ptr)\n{\n    // STACK UNDERFLOW\n    if (top == -1)\n    {\n        printf("\\nNo Element to PEEK");\n    }\n    else\n    {\n        return *(ptr + top);\n    }\n}\n'),(0,i.kt)("p",null,"Find a visual representation of solution of Stack ",(0,i.kt)("a",{parentName:"p",href:"https://yongdanielliang.github.io/animation/web/Stack.html"},"here")))}k.isMDXComponent=!0}}]);