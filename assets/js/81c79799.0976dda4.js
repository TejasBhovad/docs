"use strict";(self.webpackChunkdocsv_2=self.webpackChunkdocsv_2||[]).push([[6106],{5593:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"algorithms/bellmanFord","title":"Bellman Ford","description":"Bellman Ford in C","source":"@site/docs/three/algorithms/bellmanFord.mdx","sourceDirName":"algorithms","slug":"/algorithms/bellmanFord","permalink":"/docs/three/algorithms/bellmanFord","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11,"description":"Bellman Ford in C"},"sidebar":"tutorialSidebar","previous":{"title":"Huffman Coding","permalink":"/docs/three/algorithms/huffman"},"next":{"title":"Longest Common Subsequence","permalink":"/docs/three/algorithms/lcs"}}');var r=i(4848),d=i(8453),a=i(1432);const o='#include <stdio.h>\n\n#define INFINITY 9999\n#define MAX 10\n\nvoid bellmanFord(int G[MAX][MAX], int n, int startNode);\n\nint main() {\n    int G[MAX][MAX], i, j, n, u;\n    printf("Enter the no. of vertices: ");\n    scanf("%d", &n);\n    printf("\\nEnter the adjacency matrix:\\n");\n    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            scanf("%d", &G[i][j]);\n    printf("\\nEnter the starting node: ");\n    scanf("%d", &u);\n    bellmanFord(G, n, u);\n    return 0;\n}\n\nvoid bellmanFord(int G[MAX][MAX], int n, int startNode) {\n    int distance[MAX], pred[MAX];\n    \n    // INIT\n    for (int i = 0; i < n; i++) {\n        distance[i] = INFINITY;\n        pred[i] = -1;\n    }\n    distance[startNode] = 0;\n\n    // RELAXATION\n    for (int i = 0; i < n - 1; i++) {\n        for (int u = 0; u < n; u++) {\n            for (int v = 0; v < n; v++) {\n                if (G[u][v] != 0 && distance[u] + G[u][v] < distance[v]) {\n                    distance[v] = distance[u] + G[u][v];\n                    pred[v] = u;\n                }\n            }\n        }\n    }\n\n    // CHECK FOR NEGATIVE WEIGHT CYCLES\n    for (int u = 0; u < n; u++) {\n        for (int v = 0; v < n; v++) {\n            if (G[u][v] != 0 && distance[u] + G[u][v] < distance[v]) {\n                printf("Graph contains negative weight cycle.");\n                return;\n            }\n        }\n    }\n\n    // DISPLAY\n    for (int i = 0; i < n; i++) {\n        if (i != startNode) {\n            printf("\\nDistance of node %d = %d", i, distance[i]);\n            printf("\\nPath = %d", i);\n            int j = i;\n            while (j != startNode) {\n                j = pred[j];\n                printf(" <- %d", j);\n            }\n        }\n    }\n}\n',s={sidebar_position:11,description:"Bellman Ford in C"},l="Bellman Ford",c={},u=[{value:"CODE",id:"code",level:2}];function f(n){const e={h1:"h1",h2:"h2",header:"header",...(0,d.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"bellman-ford",children:"Bellman Ford"})}),"\n",(0,r.jsx)(e.h2,{id:"code",children:"CODE"}),"\n",(0,r.jsx)(a.A,{language:"c",children:o})]})}function h(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(f,{...n})}):f(n)}}}]);