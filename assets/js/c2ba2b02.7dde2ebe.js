"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[581],{5817:(n,e,d)=>{d.r(e),d.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>N,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var t=d(7462),i=(d(7294),d(3905)),r=d(814);const a={sidebar_position:1,description:"Adding Elements in LinkedList in C"},o="Insertion in LinkedList",s={unversionedId:"linkedlist/adding",id:"linkedlist/adding",title:"Insertion in LinkedList",description:"Adding Elements in LinkedList in C",source:"@site/docs/linkedlist/adding.mdx",sourceDirName:"linkedlist",slug:"/linkedlist/adding",permalink:"/docs/linkedlist/adding",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Adding Elements in LinkedList in C"},sidebar:"tutorialSidebar",previous:{title:"LinkedList",permalink:"/docs/category/linkedlist"},next:{title:"Journal",permalink:"/docs/category/journal"}},c={},l=[{value:"CASES IN INSERTION",id:"cases-in-insertion",level:2},{value:"CODE",id:"code",level:2}],u={toc:l};function N(n){let{components:e,...d}=n;return(0,i.kt)("wrapper",(0,t.Z)({},u,d,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"insertion-in-linkedlist"},"Insertion in LinkedList"),(0,i.kt)("h2",{id:"cases-in-insertion"},"CASES IN INSERTION"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"At Start of linkedlist"),(0,i.kt)("li",{parentName:"ol"},"At End of linkedlist"),(0,i.kt)("li",{parentName:"ol"},"After a defined(key) element"),(0,i.kt)("li",{parentName:"ol"},"Before a defined(key) element")),(0,i.kt)("h2",{id:"code"},"CODE"),(0,i.kt)(r.Z,{language:"c",mdxType:"CodeBlock"},'#include <stdlib.h>\n#include <stdio.h>\nstruct node *head = 0, *temp, *newNode;\nstruct node\n{\n    int data;\n    struct node *next;\n};\nvoid display(struct node *head)\n{\n    struct node *current = head;\n    printf("List: ");\n    while (current != 0)\n    {\n        printf("%d ", current->data);\n        current = current->next;\n    }\n    printf("\\n");\n}\nstruct node *createNode()\n{\n\n    newNode = (struct node *)malloc(sizeof(struct node));\n    newNode->next = 0;\n    if (head == 0)\n    {\n        head = newNode;\n        temp = newNode;\n    }\n    printf("\\nEnter Value to be Added: ");\n    scanf("%d", &(newNode->data));\n    return newNode;\n}\nstruct node *addNodeStart()\n{\n\n    if (head == 0)\n    {\n        printf("\\nERROR: Linked List not Defined.");\n    }\n    else\n    {\n        newNode = createNode();\n        newNode->next = head;\n        head = newNode;\n    }\n    return head;\n}\nstruct node *addNodeEnd()\n{\n\n    if (head == 0)\n    {\n        printf("\\nERROR: Linked List not Defined.");\n    }\n    else\n    {\n        newNode = createNode();\n        struct node *current = head;\n        while (current->next != 0)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n        temp = newNode;\n    }\n    return head;\n}\nstruct node *addNodeAfter()\n{\n\n    if (head == 0)\n    {\n        printf("\\nERROR: Linked List not Defined.");\n        newNode = createNode();\n        return newNode;\n    }\n    else\n    {\n        int key;\n        printf("\\nEnter Value to be added after: ");\n        scanf("%d", &key);\n        newNode = createNode();\n        struct node *current = head;\n        while (current->data != key)\n        {\n            current = current->next;\n        }\n        newNode->next = current->next;\n        current->next = newNode;\n    }\n    return head;\n}\nstruct node *addNodeBefore()\n{\n    if (head == 0)\n    {\n        // head = newNode\n        printf("\\nERROR: Linked List not Defined.");\n        newNode = createNode();\n        return newNode;\n    }\n    else\n    {\n        int key;\n        printf("\\nEnter Value to be added before: ");\n        scanf("%d", &key);\n        newNode = createNode();\n        struct node *current = head, *prev;\n        while (current->data != key)\n        {\n            prev = current;\n            current = current->next;\n        }\n        newNode->next = prev->next;\n        prev->next = newNode;\n    }\n    return head;\n}\nint main()\n{\n    // IGNORE: TEST CASES\n    // newNode = createNode();\n    // head = addNodeStart();\n    // display(head);\n    // head = addNodeEnd();\n    // display(head);\n    // head = addNodeAfter();\n    // display(head);\n    // head = addNodeBefore();\n    // display(head);\n    int choice;\n    do\n    {\n        printf("\\nENTER CHOICE:");\n        printf("\\n1. Create Node (with initial value)");\n        printf("\\n2. Add Node at Start of List");\n        printf("\\n3. Add Node at End of List");\n        printf("\\n4. Add Node after key element");\n        printf("\\n5. Add Node before key element");\n        printf("\\n6. Exit the Program\\n");\n        scanf("%d", &choice);\n        switch (choice)\n        {\n        case 1:\n        {\n            newNode = createNode();\n            display(head);\n            break;\n        }\n        case 2:\n        {\n            head = addNodeStart();\n            display(head);\n            break;\n        }\n        case 3:\n        {\n            head = addNodeEnd();\n            display(head);\n            break;\n        }\n        case 4:\n        {\n            head = addNodeAfter();\n            display(head);\n            break;\n        }\n        case 5:\n        {\n            head = addNodeBefore();\n            display(head);\n            break;\n        }\n        case 6:\n        {\n            printf("\\nExited.\\n");\n            break;\n        }\n        default:\n        {\n            printf("\\nInvalid Choice");\n            continue;\n        }\n        }\n    } while (choice != 6);\n    return 0;\n}\n'))}N.isMDXComponent=!0}}]);