"use strict";(self.webpackChunkdocsv_2=self.webpackChunkdocsv_2||[]).push([[2977],{1709:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>f,contentTitle:()=>p,default:()=>d,frontMatter:()=>c,metadata:()=>s,toc:()=>x});const s=JSON.parse('{"id":"Data Structures/stacks/postfix-convert","title":"Infix to Postfix Conversion","description":"Infix to Postfix Expressions","source":"@site/docs/two/Data Structures/stacks/postfix-convert.mdx","sourceDirName":"Data Structures/stacks","slug":"/Data Structures/stacks/postfix-convert","permalink":"/docs/two/Data Structures/stacks/postfix-convert","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"Infix to Postfix Expressions"},"sidebar":"tutorialSidebar","previous":{"title":"Stack","permalink":"/docs/two/Data Structures/stacks/"},"next":{"title":"Postfix Evaluation","permalink":"/docs/two/Data Structures/stacks/postfix-evaluate"}}');var i=e(4848),r=e(8453),o=e(1432),a=e(4748);const c={sidebar_position:3,description:"Infix to Postfix Expressions"},p="Infix to Postfix Conversion",f={},x=[];function u(n){const t={h1:"h1",header:"header",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"infix-to-postfix-conversion",children:"Infix to Postfix Conversion"})}),"\n",(0,i.jsx)(o.A,{language:"c",children:a.A})]})}function d(n={}){const{wrapper:t}={...(0,r.R)(),...n.components};return t?(0,i.jsx)(t,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},4748:(n,t,e)=>{e.d(t,{A:()=>s});const s='#include <stdio.h>\n#include <ctype.h>\n\nchar stack[100];\nint top = -1;\n\nvoid push(char x)\n{\n  top++;\n  stack[top] = x;\n}\n\nvoid display(char *ptr)\n{\n  printf("\\nElements in Stack:\\n");\n  for (int i = 0; i <= top; i++)\n  {\n    printf(" %d", *(ptr + i));\n  }\n}\n\nchar pop()\n{\n  if (top == -1)\n  {\n    printf("\\nUnderflow Error");\n    return -1;\n  }\n\n  else\n  {\n\n    return stack[top--];\n  }\n}\n\nint priority(char x)\n{\n  if (x == \'+\' || x == \'-\')\n  {\n    return 1;\n  }\n\n  if (x == \'*\' || x == \'/\' || x == \'%\')\n  {\n    return 2;\n  }\n  return 0;\n}\n\nint main()\n{\n  char exp[100];\n  char *e, x;\n  printf("Enter the expression : ");\n  scanf("%s", exp);\n  printf("\\n");\n  e = exp;\n\n  while (*e != \'\\0\')\n  {\n    if (isalnum(*e))\n    {\n      printf("%c ", *e);\n    }\n\n    else if (*e == \'(\')\n    {\n      push(*e);\n    }\n\n    else if (*e == \')\')\n    {\n      while ((x = pop()) != \'(\')\n      {\n        printf("%c ", x);\n      }\n    }\n    else\n    {\n      if (priority(*e) <= priority(stack[top]))\n      {\n        printf("%c ", pop());\n      }\n\n      push(*e);\n    }\n    e++;\n  }\n  while (top != -1)\n  {\n    printf("%c ", pop());\n  }\n\n  printf("\\n");\n  return 0;\n}\n'}}]);