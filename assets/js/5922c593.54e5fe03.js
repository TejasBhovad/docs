"use strict";(self.webpackChunkdocsv_2=self.webpackChunkdocsv_2||[]).push([[7585],{5495:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>x,frontMatter:()=>s,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"Data Structures/linkedlist/singly","title":"Singly Linked List","description":"Singly Linked List in C","source":"@site/docs/two/Data Structures/linkedlist/singly.mdx","sourceDirName":"Data Structures/linkedlist","slug":"/Data Structures/linkedlist/singly","permalink":"/docs/two/Data Structures/linkedlist/singly","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"Singly Linked List in C"},"sidebar":"tutorialSidebar","previous":{"title":"LinkedList","permalink":"/docs/two/category/linkedlist"},"next":{"title":"Singly Circular Linked List","permalink":"/docs/two/Data Structures/linkedlist/singly-circular"}}');var d=t(4848),i=t(8453),a=t(1432),l=t(3593);const s={sidebar_position:1,description:"Singly Linked List in C"},o="Singly Linked List",c={},h=[{value:"CASES IN INSERTION",id:"cases-in-insertion",level:2},{value:"CASES IN DELETION",id:"cases-in-deletion",level:2},{value:"THEORY",id:"theory",level:2},{value:"Display",id:"display",level:3},{value:"Create Node",id:"create-node",level:3},{value:"Add Node at Start",id:"add-node-at-start",level:3},{value:"Add Node at End",id:"add-node-at-end",level:3},{value:"CODE",id:"code",level:2}];function u(n){const e={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(e.header,{children:(0,d.jsx)(e.h1,{id:"singly-linked-list",children:"Singly Linked List"})}),"\n",(0,d.jsx)(e.h2,{id:"cases-in-insertion",children:"CASES IN INSERTION"}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsx)(e.li,{children:"At Start of linkedlist"}),"\n",(0,d.jsx)(e.li,{children:"At End of linkedlist"}),"\n",(0,d.jsx)(e.li,{children:"After a defined(key) element"}),"\n",(0,d.jsx)(e.li,{children:"Before a defined(key) element"}),"\n"]}),"\n",(0,d.jsx)(e.h2,{id:"cases-in-deletion",children:"CASES IN DELETION"}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsx)(e.li,{children:"Delete Elements from Start"}),"\n",(0,d.jsx)(e.li,{children:"Delete Elements from End"}),"\n",(0,d.jsx)(e.li,{children:"Delete Inputted Elements"}),"\n"]}),"\n",(0,d.jsx)(e.h2,{id:"theory",children:"THEORY"}),"\n",(0,d.jsx)(e.h3,{id:"display",children:"Display"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"use a temporary variable[*current] to store value of head in it"}),"\n",(0,d.jsx)(e.li,{children:"print the value of data of temporary variable [current->data]"}),"\n",(0,d.jsx)(e.li,{children:"set temporary variable to next address of temporary variable"}),"\n"]}),"\n",(0,d.jsx)(e.h3,{id:"create-node",children:"Create Node"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"a new node is created and required memory is allocated"}),"\n",(0,d.jsx)(e.li,{children:"set the next address of this created element to null"}),"\n",(0,d.jsxs)(e.li,{children:["IF (HEAD==0) ",(0,d.jsx)("br",{}),"\n-> set head to new node",(0,d.jsx)("br",{}),"\n-> set temp to new node",(0,d.jsx)("br",{})]}),"\n",(0,d.jsx)(e.li,{children:"INPUT value of data of new node"}),"\n",(0,d.jsx)(e.li,{children:"RETURN new node"}),"\n"]}),"\n",(0,d.jsx)(e.h3,{id:"add-node-at-start",children:"Add Node at Start"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["IF (HEAD==0)",(0,d.jsx)("br",{}),"\n-> throw error that linked list is not defined"]}),"\n",(0,d.jsxs)(e.li,{children:["ELSE",(0,d.jsx)("br",{}),"\n-> set new node to function call to create function",(0,d.jsx)("br",{}),"\n-> set next address of new node to head",(0,d.jsx)("br",{}),"\n-> set head to new node",(0,d.jsx)("br",{})]}),"\n",(0,d.jsx)(e.li,{children:"RETURN head"}),"\n"]}),"\n",(0,d.jsx)(e.h3,{id:"add-node-at-end",children:"Add Node at End"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["IF (HEAD==0)",(0,d.jsx)("br",{}),"\n-> throw error that linked list is not defined"]}),"\n",(0,d.jsxs)(e.li,{children:["ELSE",(0,d.jsx)("br",{}),"\n-> set new node to function call to create function",(0,d.jsx)("br",{}),"\n-> use a temporary variable and store value of head in it",(0,d.jsx)("br",{}),"\n-> iterate through the list till you find the last element",(0,d.jsx)("br",{}),"\n-> set next address of current variable to new node",(0,d.jsx)("br",{}),"\n-> set temp to new node",(0,d.jsx)("br",{})]}),"\n",(0,d.jsx)(e.li,{children:"RETURN head"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"More to come..."})}),"\n",(0,d.jsx)(e.h2,{id:"code",children:"CODE"}),"\n",(0,d.jsx)(a.A,{language:"c",children:l.A})]})}function x(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(u,{...n})}):u(n)}},3593:(n,e,t)=>{t.d(e,{A:()=>r});const r='#include <stdio.h>\n#include <stdlib.h>\nstruct NODE\n{\n    int data;\n    struct NODE *next;\n} typedef NODE;\nNODE *head = 0, *newNode;\n\nvoid display()\n{\n    if (head != 0)\n    {\n        NODE *current = head;\n        printf("List: ");\n        while (current != 0)\n        {\n            printf("%d ", current->data);\n            current = current->next;\n        }\n        printf("\\n");\n    }\n}\n\nvoid createNode()\n{\n    newNode = (NODE *)malloc(sizeof(NODE));\n    newNode->next = 0;\n    printf("\\nEnter Value to be Added: ");\n    scanf("%d", &(newNode->data));\n}\n\nvoid addNodeStart()\n{\n    createNode();\n    newNode->next = head;\n    head = newNode;\n}\n\nvoid addNodeEnd()\n{\n    createNode();\n    if (head == 0)\n    {\n        head = newNode;\n    }\n\n    NODE *current = head;\n    while (current->next != 0)\n    {\n        current = current->next;\n    }\n    current->next = newNode;\n    newNode->next = 0;\n}\n\nvoid addNodeAfter()\n{\n    int key;\n    printf("\\nEnter Value to be added after: ");\n    scanf("%d", &key);\n    createNode();\n    NODE *current = head;\n    while (current->data != key)\n    {\n        current = current->next;\n    }\n    newNode->next = current->next;\n    current->next = newNode;\n}\n\nvoid addNodeBefore()\n{\n    int key;\n    printf("\\nEnter Value to be added before: ");\n    scanf("%d", &key);\n    createNode();\n    NODE *current = head, *prev;\n    while (current->data != key)\n    {\n        prev = current;\n        current = current->next;\n    }\n    newNode->next = prev->next;\n    prev->next = newNode;\n}\n\nvoid deleteNodeEnd()\n{\n    if (head == 0)\n    {\n        printf("\\nERROR: No Element to Remove.");\n    }\n    else\n    {\n        NODE *current = head, *prev = 0;\n        while (current->next != 0)\n        {\n            prev = current;\n            current = current->next;\n        }\n        printf("\\nRemoved Element: %d\\n", current->data);\n        prev->next = 0;\n        free(current);\n    }\n}\n\nvoid deleteNodeStart()\n{\n    if (head == 0)\n    {\n        printf("\\nERROR: No Element to Remove.");\n    }\n    else\n    {\n        printf("\\nRemoved Element: %d\\n", head->data);\n        NODE *current = head;\n        head = current->next;\n        free(current);\n    }\n}\n\nvoid deleteNodeAt()\n{\n    if (head == 0)\n    {\n        printf("\\nERROR: No Element to Remove.");\n    }\n    else\n    {\n        int key, ctr = 0;\n        printf("\\nEnter Value to be removed: ");\n        scanf("%d", &key);\n        NODE *current = head, *prev;\n\n        while (current->data != key && current->next != 0)\n        {\n            prev = current;\n            current = current->next;\n            ctr++;\n        }\n        if (ctr == 0)\n        {\n            head = 0;\n            free(current);\n        }\n        else\n        {\n            prev->next = current->next;\n            free(current);\n        }\n    }\n}\n\nint main()\n{\n    int choice;\n    do\n    {\n        printf("\\nENTER CHOICE:");\n        printf("\\n1. Add Node at Start of List");\n        printf("\\n2. Add Node at End of List");\n        printf("\\n3. Add Node after key element");\n        printf("\\n4. Add Node before key element");\n        printf("\\n5. Delete Element from Start");\n        printf("\\n6. Delete Element from End");\n        printf("\\n7. Delete key Element");\n        printf("\\n8. EXIT\\n");\n        scanf("%d", &choice);\n        switch (choice)\n        {\n        case 1:\n        {\n            addNodeStart();\n            display();\n            break;\n        }\n        case 2:\n        {\n            addNodeEnd();\n            display();\n            break;\n        }\n        case 3:\n        {\n            addNodeAfter();\n            display();\n            break;\n        }\n        case 4:\n        {\n            addNodeBefore();\n            display();\n            break;\n        }\n        case 5:\n        {\n            deleteNodeStart();\n            display();\n            break;\n        }\n        case 6:\n        {\n            deleteNodeEnd();\n            display();\n            break;\n        }\n        case 7:\n        {\n            deleteNodeAt();\n            display();\n            break;\n        }\n        case 8:\n        {\n            printf("\\nExited.\\n");\n            break;\n        }\n        default:\n        {\n            printf("\\nInvalid Choice, Try again.\\n");\n            continue;\n        }\n        }\n    } while (choice != 8);\n    return 0;\n}'}}]);